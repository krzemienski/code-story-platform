{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/supabase/proxy.ts"],"sourcesContent":["import { createClient as createSupabaseClient } from \"@supabase/supabase-js\"\nimport { NextResponse, type NextRequest } from \"next/server\"\n\nexport async function updateSession(request: NextRequest) {\n  const supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n\n  // Skip during build time\n  if (!supabaseUrl || !supabaseAnonKey || supabaseUrl === \"placeholder\") {\n    return supabaseResponse\n  }\n\n  // Look for all possible Supabase auth cookie patterns\n  const projectRef = new URL(supabaseUrl).hostname.split(\".\")[0]\n\n  // Supabase stores session in chunks for large tokens\n  const authCookies = request.cookies\n    .getAll()\n    .filter(\n      (cookie) =>\n        cookie.name.startsWith(`sb-${projectRef}-auth-token`) ||\n        cookie.name === \"sb-access-token\" ||\n        (cookie.name.startsWith(\"sb-\") && cookie.name.includes(\"auth\")),\n    )\n\n  // Reconstruct the auth token from chunks if needed\n  let authToken: string | null = null\n\n  // Check for single token first\n  const singleToken = request.cookies.get(`sb-${projectRef}-auth-token`)?.value\n  if (singleToken) {\n    try {\n      const parsed = JSON.parse(singleToken)\n      authToken = parsed.access_token\n    } catch {\n      authToken = singleToken\n    }\n  }\n\n  // If no single token, check for chunked tokens\n  if (!authToken && authCookies.length > 0) {\n    // Sort chunks by name to ensure correct order\n    const sortedCookies = authCookies.sort((a, b) => a.name.localeCompare(b.name))\n    const combinedValue = sortedCookies.map((c) => c.value).join(\"\")\n\n    try {\n      const parsed = JSON.parse(combinedValue)\n      authToken = parsed.access_token\n    } catch {\n      // If parsing fails, it might be the raw token\n      if (sortedCookies.length === 1) {\n        authToken = sortedCookies[0].value\n      }\n    }\n  }\n\n  const supabase = createSupabaseClient(supabaseUrl, supabaseAnonKey, {\n    global: {\n      headers: authToken ? { Authorization: `Bearer ${authToken}` } : {},\n    },\n  })\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  if (request.nextUrl.pathname.startsWith(\"/dashboard\") && !user) {\n    // Check for demo mode cookie\n    const isDemoMode = request.cookies.get(\"codetales_demo_mode\")?.value === \"true\"\n    if (!isDemoMode) {\n      const url = request.nextUrl.clone()\n      url.pathname = \"/auth/login\"\n      url.searchParams.set(\"redirect\", request.nextUrl.pathname)\n      return NextResponse.redirect(url)\n    }\n  }\n\n  // Redirect logged-in users from auth pages to dashboard\n  if (request.nextUrl.pathname.startsWith(\"/auth/\") && !request.nextUrl.pathname.includes(\"/callback\") && user) {\n    const url = request.nextUrl.clone()\n    const redirectTo = request.nextUrl.searchParams.get(\"redirect\") || \"/dashboard\"\n    url.pathname = redirectTo\n    url.search = \"\"\n    return NextResponse.redirect(url)\n  }\n\n  return supabaseResponse\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,mBAAmB,8IAAY,CAAC,IAAI,CAAC;QACzC;IACF;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,wBAAwB;IACxD,MAAM,kBAAkB,QAAQ,GAAG,CAAC,6BAA6B;IAEjE,yBAAyB;IACzB,IAAI,CAAC,eAAe,CAAC,mBAAmB,gBAAgB,eAAe;QACrE,OAAO;IACT;IAEA,sDAAsD;IACtD,MAAM,aAAa,IAAI,IAAI,aAAa,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;IAE9D,qDAAqD;IACrD,MAAM,cAAc,QAAQ,OAAO,CAChC,MAAM,GACN,MAAM,CACL,CAAC,SACC,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE,WAAW,WAAW,CAAC,KACpD,OAAO,IAAI,KAAK,qBACf,OAAO,IAAI,CAAC,UAAU,CAAC,UAAU,OAAO,IAAI,CAAC,QAAQ,CAAC;IAG7D,mDAAmD;IACnD,IAAI,YAA2B;IAE/B,+BAA+B;IAC/B,MAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,WAAW,WAAW,CAAC,GAAG;IACxE,IAAI,aAAa;QACf,IAAI;YACF,MAAM,SAAS,KAAK,KAAK,CAAC;YAC1B,YAAY,OAAO,YAAY;QACjC,EAAE,OAAM;YACN,YAAY;QACd;IACF;IAEA,+CAA+C;IAC/C,IAAI,CAAC,aAAa,YAAY,MAAM,GAAG,GAAG;QACxC,8CAA8C;QAC9C,MAAM,gBAAgB,YAAY,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;QAC5E,MAAM,gBAAgB,cAAc,GAAG,CAAC,CAAC,IAAM,EAAE,KAAK,EAAE,IAAI,CAAC;QAE7D,IAAI;YACF,MAAM,SAAS,KAAK,KAAK,CAAC;YAC1B,YAAY,OAAO,YAAY;QACjC,EAAE,OAAM;YACN,8CAA8C;YAC9C,IAAI,cAAc,MAAM,KAAK,GAAG;gBAC9B,YAAY,aAAa,CAAC,EAAE,CAAC,KAAK;YACpC;QACF;IACF;IAEA,MAAM,WAAW,IAAA,8LAAoB,EAAC,aAAa,iBAAiB;QAClE,QAAQ;YACN,SAAS,YAAY;gBAAE,eAAe,CAAC,OAAO,EAAE,WAAW;YAAC,IAAI,CAAC;QACnE;IACF;IAEA,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,MAAM;QAC9D,6BAA6B;QAC7B,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC,wBAAwB,UAAU;QACzE,IAAI,CAAC,YAAY;YACf,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;YACjC,IAAI,QAAQ,GAAG;YACf,IAAI,YAAY,CAAC,GAAG,CAAC,YAAY,QAAQ,OAAO,CAAC,QAAQ;YACzD,OAAO,8IAAY,CAAC,QAAQ,CAAC;QAC/B;IACF;IAEA,wDAAwD;IACxD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,QAAQ,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,MAAM;QAC5G,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;QACjC,MAAM,aAAa,QAAQ,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,eAAe;QACnE,IAAI,QAAQ,GAAG;QACf,IAAI,MAAM,GAAG;QACb,OAAO,8IAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,OAAO;AACT"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/proxy.ts"],"sourcesContent":["import { updateSession } from \"@/lib/supabase/proxy\"\nimport type { NextRequest } from \"next/server\"\n\nexport async function proxy(request: NextRequest) {\n  return await updateSession(request)\n}\n\n// Also export as default for compatibility\nexport default proxy\n\nexport const config = {\n  matcher: [\"/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)\"],\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAGO,eAAe,MAAM,OAAoB;IAC9C,OAAO,MAAM,IAAA,yIAAa,EAAC;AAC7B;uCAGe;AAER,MAAM,SAAS;IACpB,SAAS;QAAC;KAAoF;AAChG"}}]
}